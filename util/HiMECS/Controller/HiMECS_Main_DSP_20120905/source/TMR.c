/*
*********************************************************************************************************
*                                  Embedded Systems Building Blocks
*                               Complete and Ready-to-Use Modules in C
*
*                                            Timer Manager
*
*                           (c) Copyright 1999, Jean J. Labrosse, Weston, FL
*                                          All Rights Reserved
*
* Filename   : TMR.C
* Programmer : Jean J. Labrosse
* Translated by : Won-Ho, Sung
*********************************************************************************************************
*/

/*
*********************************************************************************************************
*                                              인크루드 파일
*********************************************************************************************************
*/

#define  TMR_GLOBALS
#include "DSP2833x_Device.h"
#include "TMR.h"

/*
*********************************************************************************************************
*                                                지역변수
*********************************************************************************************************
*/

//static  INT8U       TmrTickCtr;
int t0_cnt=0;
/*
*********************************************************************************************************
*                                             지역함수 원형
*********************************************************************************************************
*/

interrupt  void        TmrTask(void);

/*$PAGE*/
/*
*********************************************************************************************************
*                                         타이머 만료 함수 설정
*
* 설명      : 타이머가 만료될 때의 사용자 함수를 설정.
* 전달인자  : n         타이머 번호 0..TMR_MAX_TMR-1
*             fnct      타이머가 만료될 때 실행될 함수의 포인터.
*             arg       'fnct'로 전달되는 인자의 포인터.
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  TmrCfgFnct (INT8U n, void (*fnct)(void *), void *arg)
{
    TMR *ptmr;


    if (n < TMR_MAX_TMR) {
        ptmr             = &TmrTbl[n];
        ptmr->TmrFnct    = fnct;                 /* 타이머에 사용자 함수 포인터를 저장한다             */
        ptmr->TmrFnctArg = arg;                  /* 사용자 함수에 대한 전달인자의 포인터를 저장한다    */
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                              타이머 점검
*
* 설명      : 이 함수는 타이머가 만료됐는지를 점검한다
* 전달인자  : n      점검하고자 하는 타이머 번호
* 리턴값    : 0      타이머가 만료됐을 경우
*             TmrCtr 타이머가 만료되기 전까지 남은 0.1초 단위의 시간
*********************************************************************************************************
*/

INT16U  TmrChk (INT8U n)
{
    INT16U val;


    val = 0;
    if (n < TMR_MAX_TMR) {
        val = TmrTbl[n].TmrCtr;
    }
    return (val);
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                          타이머 관리자 초기화
*
* 설명      : 이 함수는 타이머 관리자 모듈을 초기화 한다.
* 전달인자  : 없음
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  TmrInit (void)
{
    //INT8U  err;
    INT8U  i;
    TMR   *ptmr;


    ptmr = &TmrTbl[0];
    for (i = 0; i < TMR_MAX_TMR; i++) {          /* 모든 타이머를 리셋하고 비활성화한다                */
        ptmr->TmrEn   = FALSE;
        ptmr->TmrCtr  = 0;
        ptmr->TmrInit = 0;
        ptmr->TmrFnct = NULL;
        ptmr++;
    }
  
    
    /* DSP Timer0의 인터럽터 초기화 */
	EALLOW;	// This is needed to write to EALLOW protected registers
	PieVectTable.TINT2 = &TmrTask;	// for TINT0
	EDIS;       // This is needed to disable write to EALLOW protected registers

 
	ConfigCpuTimer(&CpuTimer2, 150, TIMER_FREQUENCY);	// 150MHz CPU Freq, 1 msec Period (in uSeconds)
//	ConfigCpuTimer(&CpuTimer2, 150, 1000);	// 150MHz CPU Freq, 1 msec Period (in uSeconds)
 
 	StartCpuTimer2();

	// Interrupt Enable Register
	IER |= M_INT14;	// for TINT2
	
	//PIE : Peripheral Interrupts setting
	PieCtrlRegs.PIEIER1.bit.INTx7 = 1;		// for TINT0
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                              타이머 리셋
*
* 설명      : 이 함수는 타이머를 초기 상태로 리셋한다.
* 전달인자  : n         리셋하고자 하는 타이머
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  TmrReset (INT8U n)
{
    TMR *ptmr;


    if (n < TMR_MAX_TMR) {
        ptmr         = &TmrTbl[n];
        ptmr->TmrCtr = ptmr->TmrInit;       /* 카운터를 리로드 한다                                    */
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                타이머 세트 (분, 초, 0.1초 단위로 지정함)
*
* 설명      : 타이머를 지정된 분, 초, 0.1초 단위로 설정한다.
*             함수는 분, 초, 0.1초의 값을 변환한다.
* 전달인자  : n         타이머 번호  0..TMR_MAX_TMR-1
*             min       분의 값
*             sec       초의 값
*             tenths    0.1초의 값
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  TmrSetMST (INT8U n, INT8U min, INT8U sec, INT8U tenths)
{
    TMR   *ptmr;
    INT16U  val;


    if (n < TMR_MAX_TMR) {
        ptmr          = &TmrTbl[n];
        val           = (INT16U)min * 600 + (INT16U)sec * 10 + (INT16U)tenths;
        ptmr->TmrInit = val;
        ptmr->TmrCtr  = val;
     }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                   타이머 세트(0.1초 단위로 지정함)
*
* 설명      : 지정된 0.1초 단위로 타이머를 설정한다.
* 전달인자  : n         타이머 번호  0..TMR_MAX_TMR-1
*             tenths    타이머에 로드 될 0.1초의 값
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  TmrSetT (INT8U n, INT16U tenths)
{ 
    TMR *ptmr;


    if (n < TMR_MAX_TMR) {
        ptmr          = &TmrTbl[n];
        ptmr->TmrInit = tenths*TIMERSCALE/TIMER_FREQUENCY;
        ptmr->TmrCtr  = tenths*TIMERSCALE/TIMER_FREQUENCY;
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                              타이머 시작
*
* 설명      : 이 함수는 타이머를 시작 시킨다.
* 전달인자  : n         시작할 타이머 번호
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  TmrStart (INT8U n)
{
    if (n < TMR_MAX_TMR) {
        TmrTbl[n].TmrEn = TRUE;
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                              타이머 정지
*
* 설명      : 이 함수는 타이머를 정지 시킨다
* 전달인자  : n         정지 시킬 타이머 번호
* 리턴값    : 없음.
*********************************************************************************************************
*/

void  TmrStop (INT8U n)
{
    if (n < TMR_MAX_TMR) {
        TmrTbl[n].TmrEn = FALSE;
    }
}

/*$PAGE*/
/*
*********************************************************************************************************
*                                          타이머 관리자 태뵀
*
* 설명      : 이 함수는 TmrInit()에 의해서 호출되며 타이머를 갱신하는 일을 한다.
*             TmrTask() 0.1초마다 실행된다.
* 전달인자  : 없음.
* 리턴값    : 없음.
* 노트      : 1) 타이머가 종료될 때 실행되는 함수는 크리티컬 섹션 밖에서 실행된다.
*
*********************************************************************************************************
*/

interrupt  void  TmrTask (void)
{
    TMR    *ptmr;
    //INT8U   err;
    INT8U   i;
    void  (*pfnct)(void *);                           /* 타이머가 만료될 때 실행될 함수                */
    void   *parg;                                     /* 위의 함수로 전달되는 인자                     */

    pfnct = (void (*)(void *))0;                      /* 함수 포인터를 리셋한다                        */
    parg  = (void *)0;

    ptmr = &TmrTbl[0];                            /* 타이머 테이블의 시작 주소로 포인트한다        */
    for (i = 0; i < TMR_MAX_TMR; i++)
    {
        if (ptmr->TmrEn == TRUE) {                /* 타이머가 활성화됐을 경우만 카운터를 감소      */
            if (ptmr->TmrCtr > 0) {
                ptmr->TmrCtr--;
                if (ptmr->TmrCtr == 0) {               /* 타이머가 만료됐는지 확인                 */
                    ptmr->TmrEn = FALSE;               /* 예, 타이머 정지                          */
                    pfnct       = ptmr->TmrFnct;       /* 실행할 함수와 그 전달인자의...           */
                    parg        = ptmr->TmrFnctArg;    /* ... 포인터를 얻는다                      */
                }
            }
        }
        if (pfnct != (void (*)(void *))0) {       /* 타이머 만료 함수를 실행해야 하는지 점검한다   */
            (*pfnct)(parg);                       
            pfnct = (void (*)(void *))0;
        }
        ptmr++;
    }

	t0_cnt++;
	// Acknowledge this interrupt to recieve more interrupts from group 1
	PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}
