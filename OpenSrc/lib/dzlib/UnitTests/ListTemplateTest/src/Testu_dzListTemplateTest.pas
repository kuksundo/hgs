unit Testu_dzListTemplateTest;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  Classes,
  TestFramework,
  u_dzQuicksort,
  u_MyItem,
  i_MyItemList,
  u_MyItemList,
  i_MyItemSortedList,
  u_MyItemSortedList,
  u_MyItemIntList,
  u_MyItemIntSortedList;

type
  // Test methods for interface IMyItemList
  TestIMyItemList = class(TTestCase)
  strict private
    FIMyItemList: IMyItemList;
    FExpectedItemLeak: integer;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure testAdd;
    procedure testExtract;
    procedure testDeleteAll;
    procedure testFreeAll;
  end;

  // Test methods for class TMyItemList
  TestTMyItemList = class(TTestCase)
  strict private
    FMyItemList: TMyItemList;
    FExpectedItemLeak: integer;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure testAdd;
    procedure testExtract;
    procedure testDeleteAll;
    procedure testFreeAll;
  end;

  // Test methods for class TMyItemSortedList
  TestTMySortedList = class(TTestCase)
  strict private
    FMySortedList: TMyItemSortedList;
    FExpectedItemLeak: integer;
  private
    procedure Fill;
    procedure InsertDupError;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure testAdd;
    procedure testInsertDupError;
    procedure testInsertDupIgnore;
    procedure testInsertDupAccept;
    procedure testDeleteAll;
    procedure testExtract;
    procedure testClear;
    procedure testFindIdx;
    procedure testFindItem;
  end;

  // Test methods for class IMyItemIntList
  TestTMyItemIntList = class(TTestCase)
  strict private
    FMyItemIntList: TMyItemIntList;
    FExpectedItemLeak: integer;
  private
    procedure Fill;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure testAdd;
    procedure testDeleteAll;
    procedure testExtract;
    procedure testClear;
  end;

  // Test methods for class TMyItemIntSortedList
  TestTMyItemIntSortedList = class(TTestCase)
  strict private
    FMyItemIntSortedList: TMyItemIntSortedList;
    FExpectedItemLeak: integer;
  private
    procedure Fill;
    procedure AddDupError;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure testAdd;
    procedure testAddDupError;
    procedure testAddDupIgnore;
    procedure testAddDupAccept;
    procedure testDeleteAll;
    procedure testExtract;
    procedure testClear;
    procedure testFindIdx;
    procedure testFindItem;
  end;

implementation

const
  INSERT_COUNT = 11;

var
  ItemCount: integer = 0;

type
  TMyItem = class(u_MyItem.TMyItem)
  public
    constructor Create(_Id: integer);
    destructor Destroy; override;
  end;

{ TMyItem }

constructor TMyItem.Create(_Id: integer);
begin
  inherited Create(_Id);
  Inc(ItemCount);
end;

destructor TMyItem.Destroy;
begin
  Dec(ItemCount);
  inherited;
end;

{ TestIMyItemList }

procedure TestIMyItemList.SetUp;
begin
  FIMyItemList := TMyItemList.Create;
  ItemCount := 0;
  FExpectedItemLeak := 0;
end;

procedure TestIMyItemList.TearDown;
begin
  FIMyItemList := nil;
  CheckEquals(FExpectedItemLeak, ItemCount, 'Items were not destroyed');
end;

procedure TestIMyItemList.testExtract;
var
  i: integer;
  Item: u_MyItem.TMyItem;
begin
  testAdd;

  for i := 0 to INSERT_COUNT - 1 do begin
    Item := FIMyItemList.Extract(0);
    CheckEquals(i, Item.Key, 'Key does not match');
    CheckEquals(INSERT_COUNT - i, ItemCount, 'Item has been destroyed');
    Item.Free;
    CheckEquals(INSERT_COUNT - 1 - i, ItemCount, 'Item has not been destroyed');
  end;
  CheckEquals(0, FIMyItemList.Count, 'List is not empty');
end;

procedure TestIMyItemList.testDeleteAll;
begin
  testAdd;
  FIMyItemList.DeleteAll;
  CheckEquals(0, FIMyItemList.Count, 'List is not empty');
  CheckEquals(INSERT_COUNT, ItemCount, 'Items were destroyed');
  FExpectedItemLeak := INSERT_COUNT;
end;

procedure TestIMyItemList.testFreeAll;
begin
  testAdd;
  FIMyItemList.Clear;
  CheckEquals(0, FIMyItemList.Count, 'List is not empty');
  CheckEquals(0, ItemCount, 'Items were not destroyed');
end;

procedure TestIMyItemList.testAdd;
var
  i: integer;
  Item: u_MyItem.TMyItem;
begin
  for i := 0 to INSERT_COUNT - 1 do begin
    FIMyItemList.Add(TMyItem.Create(i));
  end;
  CheckEquals(INSERT_COUNT, FIMyItemList.Count, 'Count does not match');
  CheckEquals(INSERT_COUNT, ItemCount, 'Number of created items does not match');

  for i := 0 to FIMyItemList.Count - 1 do begin
    Item := FIMyItemList.Items[i];
    CheckEquals(i, Item.Key, 'Key does not match');
  end;
end;

{ TestTMyItemList }

procedure TestTMyItemList.SetUp;
begin
  FMyItemList := TMyItemList.Create;
  ItemCount := 0;
end;

procedure TestTMyItemList.TearDown;
begin
  FMyItemList.Free;
  FMyItemList := nil;
  CheckEquals(FExpectedItemLeak, ItemCount, 'Items were not destroyed');
end;

procedure TestTMyItemList.testExtract;
var
  i: integer;
  Item: u_MyItem.TMyItem;
begin
  testAdd;

  for i := 0 to INSERT_COUNT - 1 do begin
    Item := FMyItemList.Extract(0);
    CheckEquals(i, Item.Key, 'Key does not match');
    CheckEquals(INSERT_COUNT - i, ItemCount, 'Item has been destroyed');
    Item.Free;
    CheckEquals(INSERT_COUNT - 1 - i, ItemCount, 'Item has not been destroyed');
  end;
  CheckEquals(0, FMyItemList.Count, 'List is not empty');
end;

procedure TestTMyItemList.testDeleteAll;
begin
  testAdd;
  FMyItemList.DeleteAll;
  CheckEquals(0, FMyItemList.Count, 'List is not empty');
  CheckEquals(INSERT_COUNT, ItemCount, 'Items were destroyed');
  FExpectedItemLeak := INSERT_COUNT;
end;

procedure TestTMyItemList.testFreeAll;
begin
  testAdd;
  FMyItemList.Clear;
  CheckEquals(0, FMyItemList.Count, 'List is not empty');
  CheckEquals(0, ItemCount, 'Items were not destroyed');
end;

procedure TestTMyItemList.testAdd;
var
  i: integer;
  Item: u_MyItem.TMyItem;
begin
  for i := 0 to INSERT_COUNT - 1 do begin
    FMyItemList.Add(TMyItem.Create(i));
  end;
  CheckEquals(INSERT_COUNT, FMyItemList.Count, 'Count does not match');
  CheckEquals(INSERT_COUNT, ItemCount, 'Number of created items does not match');

  for i := 0 to FMyItemList.Count - 1 do begin
    Item := FMyItemList.Items[i];
    CheckEquals(i, Item.Key, 'Key does not match');
  end;
end;

{ TestTMySortedList }

procedure TestTMySortedList.SetUp;
begin
  FMySortedList := TMyItemSortedList.Create;
  ItemCount := 0;
end;

procedure TestTMySortedList.TearDown;
begin
  FMySortedList.Free;
  FMySortedList := nil;
  CheckEquals(FExpectedItemLeak, ItemCount, 'Items were not destroyed');
end;

procedure TestTMySortedList.Fill;
var
  i: integer;
begin
  for i := INSERT_COUNT - 1 downto 0 do begin
    FMySortedList.Add(TMyItem.Create(i));
  end;
end;

procedure TestTMySortedList.testDeleteAll;
begin
  Fill;
  FMySortedList.DeleteAll;
  CheckEquals(0, FMySortedList.Count, 'List is not empty');
  CheckEquals(INSERT_COUNT, ItemCount, 'Items were destroyed');
  FExpectedItemLeak := INSERT_COUNT;
end;

procedure TestTMySortedList.testExtract;
var
  i: integer;
  Item: u_MyItem.TMyItem;
begin
  Fill;

  for i := 0 to INSERT_COUNT - 1 do begin
    Item := FMySortedList.Extract(0);
    CheckEquals(i, Item.Key, 'Key does not match');
    CheckEquals(INSERT_COUNT - i, ItemCount, 'Item has been destroyed');
    Item.Free;
    CheckEquals(INSERT_COUNT - 1 - i, ItemCount, 'Item has not been destroyed');
  end;
  CheckEquals(0, FMySortedList.Count, 'List is not empty');
end;

procedure TestTMySortedList.testClear;
begin
  Fill;
  FMySortedList.Clear;
  CheckEquals(0, FMySortedList.Count, 'List is not empty');
  CheckEquals(0, ItemCount, 'Items were not destroyed');
end;

procedure TestTMySortedList.testAdd;
var
  i: integer;
  Item: u_MyItem.TMyItem;
begin
  Fill;

  Assert(FMySortedList.Count = INSERT_COUNT);

  for i := 0 to FMySortedList.Count - 1 do begin
    Item := FMySortedList.Items[i];
    CheckEquals(i, Item.Key, 'Key does not match');
  end;
end;

procedure TestTMySortedList.testInsertDupAccept;
var
  Idx: Integer;
begin
  FMySortedList.Duplicates := dupAccept;
  Fill;

  FMySortedList.Add(TMyItem.Create(5));
  CheckEquals(INSERT_COUNT + 1, FMySortedList.Count, 'Count does not match');

  CheckEquals(INSERT_COUNT + 1, ItemCount, 'Number of created items does not match');

  FMySortedList.Add(TMyItem.Create(5));
  CheckEquals(INSERT_COUNT + 2, FMySortedList.Count, 'Count does not match');
  CheckTrue(FMySortedList.Find(5, Idx), 'result of Find(5)');
  CheckEquals(5, Idx, 'index of item(5)');

  CheckEquals(INSERT_COUNT + 2, ItemCount, 'Number of created items does not match');
end;

procedure TestTMySortedList.InsertDupError;
begin
  FMySortedList.Add(TMyItem.Create(5));
end;

procedure TestTMySortedList.testInsertDupError;
begin
  Fill;

  CheckException(InsertDupError, EListError, 'expected exception did not occur');

  FExpectedItemLeak := 1;
end;

procedure TestTMySortedList.testInsertDupIgnore;
begin
  FMySortedList.Duplicates := dupIgnore;
  Fill;

  FMySortedList.Add(TMyItem.Create(5));
  CheckEquals(INSERT_COUNT, FMySortedList.Count, 'Count does not match');

  CheckEquals(INSERT_COUNT + 1, ItemCount, 'Number of created items does not match');

  FExpectedItemLeak := 1;
end;

procedure TestTMySortedList.testFindIdx;
var
  Idx: integer;
begin
  Fill;

  CheckTrue(FMySortedList.Find(5, Idx), 'item not found');
  CheckEquals(5, Idx, 'Item does not have expected index');
end;

procedure TestTMySortedList.testFindItem;
var
  Item: u_MyItem.TMyItem;
begin
  Fill;

  CheckTrue(FMySortedList.Find(5, Item), 'item not found');
  CheckEquals(5, Item.Key, 'Item does not have expected Key');
end;

{ TestTMyItemIntList }

procedure TestTMyItemIntList.Fill;
var
  i: integer;
begin
  for i := 0 to INSERT_COUNT - 1 do begin
    FMyItemIntList.Add(TMyItem.Create(i));
  end;
end;

procedure TestTMyItemIntList.SetUp;
begin
  FMyItemIntList := TMyItemIntList.Create;
  ItemCount := 0;
  FExpectedItemLeak := 0;
end;

procedure TestTMyItemIntList.TearDown;
begin
  FMyItemIntList.Free;
  CheckEquals(FExpectedItemLeak, ItemCount, 'Items were not destroyed');
end;

procedure TestTMyItemIntList.testDeleteAll;
begin
  Fill;
  FMyItemIntList.DeleteAll;
  CheckEquals(0, FMyItemIntList.Count, 'List is not empty');
  CheckEquals(0, ItemCount, 'Items were not destroyed');
end;

procedure TestTMyItemIntList.testExtract;
var
  i: integer;
  Item: u_MyItem.IMyItem;
begin
  Fill;

  for i := 0 to INSERT_COUNT - 1 do begin
    Item := FMyItemIntList.Extract(0);
    CheckEquals(i, Item.Key, 'Key does not match');
    CheckEquals(INSERT_COUNT - i, ItemCount, 'Item has been destroyed');
    Item := nil;
    CheckEquals(INSERT_COUNT - 1 - i, ItemCount, 'Item has not been destroyed');
  end;
  CheckEquals(0, FMyItemIntList.Count, 'List is not empty');
end;

procedure TestTMyItemIntList.testClear;
begin
  Fill;
  FMyItemIntList.Clear;
  CheckEquals(0, FMyItemIntList.Count, 'List is not empty');
  CheckEquals(0, ItemCount, 'Items were not destroyed');
end;

procedure TestTMyItemIntList.testAdd;
var
  i: integer;
  Item: u_MyItem.IMyItem;
begin
  for i := 0 to INSERT_COUNT - 1 do begin
    FMyItemIntList.Add(TMyItem.Create(i));
  end;
  CheckEquals(INSERT_COUNT, FMyItemIntList.Count, 'Count does not match');
  CheckEquals(INSERT_COUNT, ItemCount, 'Number of created items does not match');

  for i := 0 to FMyItemIntList.Count - 1 do begin
    Item := FMyItemIntList.Items[i];
    CheckEquals(i, Item.Key, 'Key does not match');
  end;
end;

{ TestTMyItemIntSortedList }

procedure TestTMyItemIntSortedList.SetUp;
begin
  FMyItemIntSortedList := TMyItemIntSortedList.Create;
  ItemCount := 0;
  FExpectedItemLeak := 0;
end;

procedure TestTMyItemIntSortedList.TearDown;
begin
  FMyItemIntSortedList.Free;
  FMyItemIntSortedList := nil;
  CheckEquals(FExpectedItemLeak, ItemCount, 'Items were not destroyed');
end;

procedure TestTMyItemIntSortedList.Fill;
var
  i: integer;
begin
  for i := INSERT_COUNT - 1 downto 0 do begin
    FMyItemIntSortedList.Add(TMyItem.Create(i));
  end;
end;

procedure TestTMyItemIntSortedList.testDeleteAll;
begin
  Fill;
  FMyItemIntSortedList.DeleteAll;
  CheckEquals(0, FMyItemIntSortedList.Count, 'List is not empty');
  CheckEquals(0, ItemCount, 'Items were destroyed');
  FExpectedItemLeak := 0;
end;

procedure TestTMyItemIntSortedList.testExtract;
var
  i: integer;
  Item: u_MyItem.IMyItem;
begin
  Fill;

  for i := 0 to INSERT_COUNT - 1 do begin
    Item := FMyItemIntSortedList.Extract(0);
    CheckEquals(i, Item.Key, 'Key does not match');
    CheckEquals(INSERT_COUNT - i, ItemCount, 'Item has been destroyed');
    Item := nil;
    CheckEquals(INSERT_COUNT - 1 - i, ItemCount, 'Item has not been destroyed');
  end;
  CheckEquals(0, FMyItemIntSortedList.Count, 'List is not empty');
end;

procedure TestTMyItemIntSortedList.testClear;
begin
  Fill;
  FMyItemIntSortedList.Clear;
  CheckEquals(0, FMyItemIntSortedList.Count, 'List is not empty');
  CheckEquals(0, ItemCount, 'Items were not destroyed');
end;

procedure TestTMyItemIntSortedList.testAdd;
var
  i: integer;
  Item: u_MyItem.IMyItem;
begin
  Fill;

  Assert(FMyItemIntSortedList.Count = INSERT_COUNT);

  for i := 0 to FMyItemIntSortedList.Count - 1 do begin
    Item := FMyItemIntSortedList.Items[i];
    CheckEquals(i, Item.Key, 'Key does not match');
  end;
end;

procedure TestTMyItemIntSortedList.testAddDupAccept;
begin
  FMyItemIntSortedList.Duplicates := dupAccept;
  Fill;

  FMyItemIntSortedList.Add(TMyItem.Create(5));
  CheckEquals(INSERT_COUNT + 1, FMyItemIntSortedList.Count, 'Count does not match');

  CheckEquals(INSERT_COUNT + 1, ItemCount, 'Number of created items does not match');
end;

procedure TestTMyItemIntSortedList.AddDupError;
begin
  FMyItemIntSortedList.Add(TMyItem.Create(5));
end;

procedure TestTMyItemIntSortedList.testAddDupError;
begin
  Fill;

  CheckException(AddDupError, EListError, 'expected exception did not occur');
end;

procedure TestTMyItemIntSortedList.testAddDupIgnore;
begin
  FMyItemIntSortedList.Duplicates := dupIgnore;
  Fill;

  FMyItemIntSortedList.Add(TMyItem.Create(5));
  CheckEquals(INSERT_COUNT, FMyItemIntSortedList.Count, 'Count does not match');

  CheckEquals(INSERT_COUNT, ItemCount, 'Number of created items does not match');
end;

procedure TestTMyItemIntSortedList.testFindIdx;
var
  Idx: integer;
begin
  Fill;

  CheckTrue(FMyItemIntSortedList.Find(5, Idx), 'item not found');
  CheckEquals(5, Idx, 'Item does not have expected index');
end;

procedure TestTMyItemIntSortedList.testFindItem;
var
  Item: u_MyItem.IMyItem;
begin
  Fill;

  CheckTrue(FMyItemIntSortedList.Find(5, Item), 'item not found');
  CheckEquals(5, Item.Key, 'Item does not have expected Key');
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestIMyItemList.Suite);
  RegisterTest(TestTMyItemList.Suite);
  RegisterTest(TestTMySortedList.Suite);
  RegisterTest(TestTMyItemIntList.Suite);
  Registertest(TestTMyItemIntSortedList.Suite);
end.

