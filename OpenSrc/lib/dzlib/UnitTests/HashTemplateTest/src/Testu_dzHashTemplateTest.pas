unit Testu_dzHashTemplateTest;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework,
  u_MyItemHash,
  Classes,
  u_MyItem;

type
  // Test methods for class TMyItemHash
  TestTMyItemHash = class(TTestCase)
  strict private
    FMyItemHash: TMyItemHash;
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure testFill;
    procedure testExtract;
    procedure testAssignNil;
    procedure testFindKeyOf;
    procedure testGetAllKeys;
    procedure testKeysProperty;
    procedure testValuesProperty;
  end;

implementation

type
  TCharHash = 'a'..'z';
  TCharHashSet = set of TCharHash;
const
  CHAR_HASH_COUNT = Ord(high(TCharHash)) - Ord(low(TCharHash)) + 1;
  CHAR_HASH_SET_FULL = [low(TCharHash)..high(TCharHash)];

procedure TestTMyItemHash.SetUp;
begin
  FMyItemHash := TMyItemHash.Create;
end;

procedure TestTMyItemHash.TearDown;
begin
  FMyItemHash.Free;
  FMyItemHash := nil;
end;

procedure TestTMyItemHash.testAssignNil;
var
  c: TCharHash;
  Item: TMyItem;
begin
  testFill;
  for c := low(TCharHash) to high(TCharHash) do begin
    CheckTrue(FMyItemHash.Contains(c));
    Item := FMyItemHash[c];
    CheckTrue(FMyItemHash.Contains(c));
    FMyItemHash[c] := nil;
    CheckFalse(FMyItemHash.Contains(c));
    Item.Free;
  end;
end;

procedure TestTMyItemHash.testExtract;
var
  c: TCharHash;
  Item: TMyItem;
begin
  testFill;
  for c := high(TCharHash) downto low(TCharHash) do begin
    CheckTrue(FMyItemHash.Contains(c));
    Item := FMyItemHash.Extract(c);
    CheckFalse(FMyItemHash.Contains(c));
    CheckEquals(ord(c), Item.Key);
    Item.Free;
  end;
end;

procedure TestTMyItemHash.testFill;
var
  c: TCharHash;
  Item: TMyItem;
begin
  for c := low(TCharHash) to high(TCharHash) do begin
    CheckFalse(FMyItemHash.Contains(c));
    FMyItemHash[c] := TMyItem.Create(ord(c));
    Checktrue(FMyItemHash.Contains(c));
    Item := FMyItemHash[c];
    CheckEquals(Ord(c), Item.Key);
  end;
  CheckEquals(CHAR_HASH_COUNT, FMyItemHash.Count);
end;

procedure TestTMyItemHash.testFindKeyOf;
var
  c: TCharHash;
  Item: TMyItem;
  FoundKey: string;
  FindResult: boolean;
begin
  testFill;
  for c := high(TCharHash) downto low(TCharHash) do begin
    CheckTrue(FMyItemHash.Contains(c));
    Item := FMyItemHash[c];
    FindResult := FMyItemHash.FindKeyOf(Item, FoundKey);
    CheckTrue(FindResult);
    CheckEquals(c, FoundKey);
  end;
end;

procedure TestTMyItemHash.testGetAllKeys;
var
  st: TStringList;
  c: TCharHash;
begin
  testFill;

  CheckEquals(CHAR_HASH_COUNT, FMyItemHash.GetAllKeys(nil));

  st := TStringList.Create;
  try
    CheckEquals(CHAR_HASH_COUNT, FMyItemHash.GetAllKeys(st));
    CheckEquals(CHAR_HASH_COUNT, st.Count);
    st.Sort;
    for c := low(TCharHash) to high(TCharHash) do
      CheckEquals(c, st[Ord(c) - Ord(low(TCharHash))]);
  finally
    st.Free;
  end;
end;

procedure TestTMyItemHash.testKeysProperty;
var
  i: integer;
  s: string;
  Keys: set of TCharHash;
begin
  testFill;
  Keys := CHAR_HASH_SET_FULL;
  for i := 0 to FMyItemHash.Count - 1 do begin
    s := FMyItemHash.Keys[i];
    CheckEquals(1, Length(s));
    CheckTrue(s[1] in Keys);
    Exclude(Keys, AnsiChar(s[1]));
  end;
  CheckTrue(Keys = []);
end;

procedure TestTMyItemHash.testValuesProperty;
var
  i: integer;
  c: AnsiChar;
  Keys: set of TCharHash;
  Item: TMyItem;
begin
  testFill;
  Keys := CHAR_HASH_SET_FULL;
  for i := 0 to FMyItemHash.Count - 1 do begin
    Item := FMyItemHash.Items[i];
    c := AnsiChar(Item.Key);
    CheckTrue(c in Keys);
    Exclude(Keys, c);
  end;
  CheckTrue(Keys = []);
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTMyItemHash.Suite);
end.

